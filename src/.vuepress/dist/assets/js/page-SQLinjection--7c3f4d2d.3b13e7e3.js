(window.webpackJsonp = window.webpackJsonp || []).push([[38], { 496: function(e, t, a) { "use strict"; a.r(t); var s = a(2), n = Object(s.a)({}, (function() { var e = this, t = e.$createElement, a = e._self._c || t; return a("ContentSlotsDistributor", { attrs: { "slot-key": e.$parent.slotKey } }, [a("h1", { attrs: { id: "sql-injection" } }, [a("a", { staticClass: "header-anchor", attrs: { href: "#sql-injection" } }, [e._v("#")]), e._v(" SQL injection?")]), e._v(" "), a("h3", { attrs: { id: "how-these-attacks-work-and-how-to-prevent-them" } }, [a("a", { staticClass: "header-anchor", attrs: { href: "#how-these-attacks-work-and-how-to-prevent-them" } }, [e._v("#")]), e._v(" "), a("em", [e._v("How these attacks work and how to prevent them")])]), e._v(" "), a("br"), e._v(" "), a("h3", { attrs: { id: "there-are-several-types-of-sql-injection-but-they-all-involve-an-attacker-inserting-arbitrary-sql-into-a-web-application-database-query-the-good-news-sql-injection-is-the-lowest-of-the-low-hanging-fruit-for-both-attackers-and-defenders" } }, [a("a", { staticClass: "header-anchor", attrs: { href: "#there-are-several-types-of-sql-injection-but-they-all-involve-an-attacker-inserting-arbitrary-sql-into-a-web-application-database-query-the-good-news-sql-injection-is-the-lowest-of-the-low-hanging-fruit-for-both-attackers-and-defenders" } }, [e._v("#")]), e._v(" There are several types of SQL injection, but they all involve an attacker inserting arbitrary SQL into a web application database query. The good news? SQL injection is the lowest of the low-hanging fruit for both attackers and defenders.")]), e._v(" "), a("br"), e._v(" "), a("p", [e._v('Immortalized by "Little Bobby Drop Tables" in '), a("a", { attrs: { href: "https://xkcd.com/327/", target: "_blank", rel: "noopener noreferrer" } }, [e._v("XKCD 327"), a("OutboundLink")], 1), e._v(", SQL injection (SQLi) was first discovered in 1998, yet continues to plague web applications across the internet. Even the "), a("a", { attrs: { href: "https://www.owasp.org/index.php/Top_10-2017_A1-Injection", target: "_blank", rel: "noopener noreferrer" } }, [e._v("OWASP Top Ten"), a("OutboundLink")], 1), e._v(" lists injection as the number one threat to web application security.")]), e._v(" "), a("h2", { attrs: { id: "sql-injection-definition" } }, [a("a", { staticClass: "header-anchor", attrs: { href: "#sql-injection-definition" } }, [e._v("#")]), e._v(" SQL injection definition")]), e._v(" "), a("p", [e._v("SQL injection is a type of attack that can give an adversary complete control over your web application database by inserting arbitrary SQL code into a database query.")]), e._v(" "), a("p", [e._v("The good news? SQL injection is the lowest of the low-hanging fruit for both attackers and defenders. It isn't some cutting edge NSA Shadow Brokers kit, it's so simple "), a("a", { attrs: { href: "https://www.troyhunt.com/hacking-is-childs-play-sql-injection/", target: "_blank", rel: "noopener noreferrer" } }, [e._v("a three-year old can do it"), a("OutboundLink")], 1), e._v(". This is script kiddie stuff---and fixing your web application to mitigate the risk of SQL injection is so easy that failure to do so looks more and more like gross negligence.")]), e._v(" "), a("h2", { attrs: { id: "sql-injection-attacks" } }, [a("a", { staticClass: "header-anchor", attrs: { href: "#sql-injection-attacks" } }, [e._v("#")]), e._v(" SQL injection attacks")]), e._v(" "), a("p", [e._v("There are several types of SQL injection, but they all involve an attacker inserting arbitrary SQL into a web application database query. The simplest form of SQL injection is through user input. Web applications typically accept user input through a form, and the front end passes the user input to the back-end database for processing. If the web application fails to sanitize user input, an attacker can inject SQL of their choosing into the back-end database and delete, copy, or modify the contents of the database.")]), e._v(" "), a("p", [e._v("An attacker can also modify cookies to poison a web application's database query. Cookies store client state information locally, and web applications commonly load cookies and process that information. A malicious user, or "), a("a", { attrs: { href: "https://www.csoonline.com/article/3295877/malware/what-is-malware-viruses-worms-trojans-and-beyond.html", target: "_blank", rel: "noopener noreferrer" } }, [e._v("malware"), a("OutboundLink")], 1), e._v(", can modify cookies to inject SQL into the back-end database.")]), e._v(" "), a("p", [e._v("Server variables such as HTTP headers can also be used as a SQL injection attack vector. Forged headers containing arbitrary SQL can inject that code into the database if the web application fails to sanitize those inputs as well.")]), e._v(" "), a("p", [e._v("Second-order SQL injection attacks are the sneakiest of the bunch, because they aren't designed to run immediately, but much later. A developer who correctly sanitizes all their input against an immediate attack may still be vulnerable to a second-order SQLi when the poisoned data is used in a different context.")]), e._v(" "), a("h2", { attrs: { id: "sql-injection-tools" } }, [a("a", { staticClass: "header-anchor", attrs: { href: "#sql-injection-tools" } }, [e._v("#")]), e._v(" SQL injection tools")]), e._v(" "), a("p", [e._v("SQL injection, as a technique, is older than many of the human attackers using them today; the attacks are rudimentary and have long since been automated. Tools like SQLninja, SQLmap, and Havij make it easy to test your own web applications, but also make it easy for attackers.")]), e._v(" "), a("p", [e._v("Ten years ago, a "), a("a", { attrs: { href: "https://isc.sans.edu/diary/SQL+Injection+Worm+on+the+Loose+%28UPDATED+x2%29/4393", target: "_blank", rel: "noopener noreferrer" } }, [e._v("SQL injection worm"), a("OutboundLink")], 1), e._v(" rampaged across the internet. Cut to the present: Not much has changed. Despite a widespread awareness of SQL injection as a problem, a large percentage of web applications remains vulnerable.")]), e._v(" "), a("p", [e._v("Automated testing tools can keep you a step ahead of attackers looking for an easy payday. Pentesting your web applications with a tool like SQLmap is a quick way to see if your mitigations are adequate. SQLmap supports pretty much every major database in use today and can detect and exploit most known SQL injection vulnerabilities.")]), e._v(" "), a("p", [e._v("Sanitize your input, but test to verify your mitigations are successful. A useful reminder: "), a("a", { attrs: { href: "https://www.csoonline.com/article/2122440/disaster-recovery/emergency-preparedness-red-team-versus-blue-team-how-to-run-an-effective-simulation.html", target: "_blank", rel: "noopener noreferrer" } }, [e._v("Blue team and red team"), a("OutboundLink")], 1), e._v(" are two sides to the same coin.")]), e._v(" "), a("h2", { attrs: { id: "sql-injection-example" } }, [a("a", { staticClass: "header-anchor", attrs: { href: "#sql-injection-example" } }, [e._v("#")]), e._v(" SQL injection example")]), e._v(" "), a("p", [e._v("Let's look at a basic SQL injection attack. Suppose you've built a web application that lets customers enter their customer IDs and retrieve their customer profiles. The web application front end passes the user-entered customer ID to the back-end database. The database runs an SQL query and returns the results to the web application, which displays the results to the end user.")]), e._v(" "), a("p", [e._v("The back-end database query might look something like this:")]), e._v(" "), a("div", { staticClass: "language-sql extra-class" }, [a("pre", { pre: !0, attrs: { class: "language-sql" } }, [a("code", [a("span", { pre: !0, attrs: { class: "token keyword" } }, [e._v("SELECT")]), e._v(" "), a("span", { pre: !0, attrs: { class: "token operator" } }, [e._v("*")]), e._v("\n"), a("span", { pre: !0, attrs: { class: "token keyword" } }, [e._v("FROM")]), e._v(" customers\n"), a("span", { pre: !0, attrs: { class: "token keyword" } }, [e._v("WHERE")]), e._v(" customer_id "), a("span", { pre: !0, attrs: { class: "token operator" } }, [e._v("=")]), e._v(" "), a("span", { pre: !0, attrs: { class: "token string" } }, [e._v("'1234567'")]), e._v("\n")])])]), a("p", [e._v("Suppose a user entered the following customer_id in a web form field:")]), e._v(" "), a("div", { staticClass: "language-sql extra-class" }, [a("pre", { pre: !0, attrs: { class: "language-sql" } }, [a("code", [e._v("           "), a("span", { pre: !0, attrs: { class: "token number" } }, [e._v("1234567")]), a("span", { pre: !0, attrs: { class: "token punctuation" } }, [e._v(";")]), e._v(" "), a("span", { pre: !0, attrs: { class: "token keyword" } }, [e._v("DELETE")]), e._v(" "), a("span", { pre: !0, attrs: { class: "token operator" } }, [e._v("*")]), e._v(" customers "), a("span", { pre: !0, attrs: { class: "token keyword" } }, [e._v("WHERE")]), e._v(" "), a("span", { pre: !0, attrs: { class: "token string" } }, [e._v("'1'")]), e._v(" "), a("span", { pre: !0, attrs: { class: "token operator" } }, [e._v("=")]), e._v(" '"), a("span", { pre: !0, attrs: { class: "token number" } }, [e._v("1")]), e._v("\n")])])]), a("p", [e._v("The back-end database would then obediently execute the following SQL:")]), e._v(" "), a("div", { staticClass: "language-sql extra-class" }, [a("pre", { pre: !0, attrs: { class: "language-sql" } }, [a("code", [a("span", { pre: !0, attrs: { class: "token keyword" } }, [e._v("SELECT")]), e._v(" "), a("span", { pre: !0, attrs: { class: "token operator" } }, [e._v("*")]), e._v("\n"), a("span", { pre: !0, attrs: { class: "token keyword" } }, [e._v("FROM")]), e._v(" customers\n"), a("span", { pre: !0, attrs: { class: "token keyword" } }, [e._v("WHERE")]), e._v(" customer_id "), a("span", { pre: !0, attrs: { class: "token operator" } }, [e._v("=")]), e._v(" "), a("span", { pre: !0, attrs: { class: "token string" } }, [e._v("'1234567'")]), a("span", { pre: !0, attrs: { class: "token punctuation" } }, [e._v(";")]), e._v("\n"), a("span", { pre: !0, attrs: { class: "token keyword" } }, [e._v("DELETE")]), e._v(" "), a("span", { pre: !0, attrs: { class: "token operator" } }, [e._v("*")]), e._v("\n"), a("span", { pre: !0, attrs: { class: "token keyword" } }, [e._v("FROM")]), e._v(" customers\n"), a("span", { pre: !0, attrs: { class: "token keyword" } }, [e._v("WHERE")]), e._v(" "), a("span", { pre: !0, attrs: { class: "token string" } }, [e._v("'x'")]), e._v(" "), a("span", { pre: !0, attrs: { class: "token operator" } }, [e._v("=")]), e._v(" "), a("span", { pre: !0, attrs: { class: "token string" } }, [e._v("'x'")]), e._v("\n")])])]), a("p", [e._v('Remember, databases will happily execute multiple SQL statements in a row if separated by a semicolon. Failure to sanitize the user input for the single quote "\'" character makes it possible for an attacker to delete the entire table. Hope you had good backups. Right? Right...?')]), e._v(" "), a("p", [e._v("This was a deliberately simple example, and there are many different SQL injection attack vectors, but all work on the same principle: A web application's failure to sanitize input leads to remote SQL code execution.")]), e._v(" "), a("h2", { attrs: { id: "how-to-detect-sql-injection-attacks" } }, [a("a", { staticClass: "header-anchor", attrs: { href: "#how-to-detect-sql-injection-attacks" } }, [e._v("#")]), e._v(" How to detect SQL injection attacks")]), e._v(" "), a("p", [e._v("Mitigating SQL injection attacks is not difficult, but even the smartest and best-intentioned developers still make mistakes. Detection is therefore an important component of mitigating the risk of a SQL injection attack. A web application firewall (WAF) can detect and block basic SQL injection attacks, but you shouldn't rely on it as the sole preventive measure.")]), e._v(" "), a("p", [a("a", { attrs: { href: "https://www.csoonline.com/article/3255632/network-security/what-is-an-intrusion-detection-system-ids-a-valued-capability-with-serious-management-challenges.html", target: "_blank", rel: "noopener noreferrer" } }, [e._v("Intrusion detection systems (IDS)"), a("OutboundLink")], 1), e._v(", both network- and host-based, can be tuned to detect SQL injection attacks. Network-based IDSes can monitor all connections to your database server, and flag suspicious activity. A host-based IDS can monitor web server logs and alert when something strange happens.")]), e._v(" "), a("p", [e._v("Ultimately, though, SQL injection attacks are well-understood and easily preventable, and the priority for risk mitigation should be preventing SQL injection attacks in the first place.")]), e._v(" "), a("h2", { attrs: { id: "how-to-prevent-sql-injection-attacks" } }, [a("a", { staticClass: "header-anchor", attrs: { href: "#how-to-prevent-sql-injection-attacks" } }, [e._v("#")]), e._v(" How to prevent SQL injection attacks")]), e._v(" "), a("p", [e._v('Listen to Little Bobby Tables and sanitize your database inputs. Any input to your web application database should be considered untrustworthy and treated accordingly. And listen to the good folks from OWASP when they tell you "It\'s somewhat shameful that there are so many successful SQL Injection attacks occurring, because it is EXTREMELY simple to avoid SQL injection vulnerabilities in your code." [their emphasis]')]), e._v(" "), a("p", [e._v("The "), a("a", { attrs: { href: "https://www.owasp.org/index.php/SQL_Injection_Prevention_Cheat_Sheet", target: "_blank", rel: "noopener noreferrer" } }, [e._v("OWASP SQL injection cheat sheet"), a("OutboundLink")], 1), e._v(" dives deeper than we ever could here, but preventing SQL injection attacks, the OWASP tell us, requires developers to whitelist input validation (not blacklisting), to use prepared statements with parameterized queries, and to escape all user-supplied input.")]), e._v(" "), a("p", [e._v("Also limit account privileges. Assume a breach. What if a developer fails to sanitize a single user input field? Hey, it happens. Developers are only human. Sanitize input but assume something is going to slip past you. Limit the account privileges of the database user. Is your web application read only, for example? Does it need to have DROP TABLES privileges? Probably not. The principle of least privilege applies here. Give the web application the minimum privileges it needs to run.")]), e._v(" "), a("p", [e._v("Stored procedures can also make SQLi a lot harder --- although not impossible. If your web application only needs to run a handful of SQL queries, create stored procedures to execute those queries. Typically, only the database administrator has privileges to create or modify stored procedures. Be aware, though, that many databases ship with default stored procedures out of the box, and attackers know this. Consider removing those default stored procedures unless you really need them.")]), e._v(" "), a("p", [e._v("SQL injection is the lowest of the low-hanging web application security fruit. This well-known attack vector is easily exploited by unsophisticated attackers, but it is easily mitigated with a small amount of due diligence. In 2018 there is no longer any excuse for a web application to be vulnerable to SQL injection. This is what minimum due diligence in web application security looks like, folks.")]), e._v(" "), a("br"), e._v(" "), a("br"), e._v(" "), a("hr"), e._v(" "), a("small", [e._v("Porup, J. (2018, October 02). What is SQL injection? How these attacks work and how to prevent them. Retrieved November 13, 2020, from https://www.csoonline.com/article/3257429/what-is-sql-injection-how-these-attacks-work-and-how-to-prevent-them.html")]), e._v(" "), a("br")]) }), [], !1, null, null, null); t.default = n.exports } }]);